/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Zip.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Zip
 #	author : miyako
 #	2019/08/30
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Zip.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Zip
            
			case 1 :
				Unzip(params);
				break;
			case 2 :
				Zip(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void Unzip(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_TEXT Param5;
    C_LONGINT Param6;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//options
    Param5.fromParamAtIndex(pParams, 5);//callback
    Param6.fromParamAtIndex(pParams, 6);//codepage
    
    //pass
    std::string password;
    convertToString(Param3, password);
    bool with_password = (password.length() != 0);
    const char *pass = with_password ? password.c_str() : NULL;
    
    //src, dst
    CUTF8String input_path;
    Param1.copyPath(&input_path);
    const char *input = (const char*)input_path.c_str();
#if VERSIONMAC
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();
#else
    const wchar_t *output = (const wchar_t*)Param2.getUTF16StringPtr();
#endif
    
    unsigned int flags = Param4.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;
#endif
    
#if VERSIONWIN
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
    DWORD codepage = 0;
#endif
    
    //callback
#if USE_PA_EXECUTE_METHOD_BY_ID
    PA_long32 method_id = PA_GetMethodID((PA_Unichar *)Param5.getUTF16StringPtr());
#else
    PA_long32 method_id = 0;
#endif
    
//    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
#if LESS_CALLBACK
    time_t startTime = time(0);
    unsigned int yield_counter = 0;
#endif
    
    bool isCallbackSet = Param5.getUTF16Length();
    
    bool abortedByCallbackMethod = false;
    //    bool use_callback = Param5.getUTF16Length();
    
    PA_Variable    cbparams[8];
    
    if(method_id)
    {
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Unistring);
        cbparams[2] = PA_CreateVariable(eVK_Real);
        cbparams[3] = PA_CreateVariable(eVK_Real);
        cbparams[4] = PA_CreateVariable(eVK_Real);
        cbparams[5] = PA_CreateVariable(eVK_Real);
        cbparams[6] = PA_CreateVariable(eVK_Undefined);
        cbparams[7] = PA_CreateVariable(eVK_Undefined);
    }else{
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Boolean);
        cbparams[2] = PA_CreateVariable(eVK_Unistring);
        cbparams[3] = PA_CreateVariable(eVK_Unistring);
        cbparams[4] = PA_CreateVariable(eVK_Real);
        cbparams[5] = PA_CreateVariable(eVK_Real);
        cbparams[6] = PA_CreateVariable(eVK_Real);
        cbparams[7] = PA_CreateVariable(eVK_Real);
        PA_SetUnistring((&(cbparams[0].uValue.fString)),
                        (PA_Unichar *)Param5.getUTF16StringPtr());
    }
    
    int charset = Param6.getIntValue();
    
    double number_entry = 0;
    double num_of_file = 0;
    
    void *reader = NULL;
    
    mz_zip_reader_create(&reader);
    mz_zip_reader *h = (mz_zip_reader *)reader;
    
    std::vector<uint8_t> buf(BUFFER_SIZE);
    
    if(with_password)
    {
        mz_zip_writer_set_password(reader, pass);
    }
    
    int32_t err = mz_zip_reader_open_file(reader, input);
    
    if (err == MZ_OK)
    {
        returnValue.setIntValue(1);
        
#if VERSIONMAC
        NSFileManager *fm = [[NSFileManager alloc]init];
        
        NSMutableArray *symlinkSrcPaths = [[NSMutableArray alloc]init];
        NSMutableArray *symlinkDstPaths = [[NSMutableArray alloc]init];
        
        std::vector<TextEncoding> _encodings;
        TextEncoding *encodings = NULL;
        TECSnifferObjectRef sniffer = NULL;
        int len = MAX_LENGTH_FOR_ENCODING_NAME;
        ItemCount charset_count, charset_num;
        ItemCount numTextEncodings;
        ItemCount maxErrs;
        ItemCount maxFeatures;
        ItemCount *numErrsArray;
        if(charset == CHARSET_AUTOMATIC)
        {
            if(!TECCountAvailableTextEncodings(&charset_count))
            {
                _encodings.resize(charset_count);
                encodings = &_encodings[0];
                TECGetAvailableTextEncodings(encodings, charset_count, &charset_num);
                TECCreateSniffer(&sniffer, encodings, charset_num);
            }
        }
#else
        ULONG numTextEncodings = 0;
        if(mlang)
        {
            ULONG charset_count, charset_celt = 32;//    number of codes page information to retrive at a time
            MIMECPINFO charset_infos[32];
            IEnumCodePage* codepages = NULL;
            mlang->EnumCodePages(MIMECONTF_VALID, 0, &codepages);
            if(codepages)
            {
                while(codepages->Next(charset_celt, charset_infos, &charset_count) == S_OK)
                {
                    numTextEncodings += charset_count;
                }
                codepages->Release();
            }
        }
#endif
        mz_zip_file *zi = NULL;
        
        err = mz_zip_reader_goto_first_entry(reader);
        
        if (err == MZ_OK)
        {
            number_entry++;
            
            do
            {
                err = mz_zip_reader_entry_get_info(reader, &zi);
                
                if (err == MZ_OK)
                {
                    
                    err = mz_zip_reader_goto_next_entry(reader);
                    if (err == MZ_OK)
                    {
                        number_entry++;
                    }
                }
                
            }while (err == MZ_OK);
            
            if (err == MZ_END_OF_LIST)
            {
                err = mz_zip_reader_goto_first_entry(reader);
                
                if (err == MZ_OK)
                {
                    num_of_file++;
                    
                    do
                    {
                        err = mz_zip_reader_entry_get_info(reader, &zi);
                        
                        if (err == MZ_OK)
                        {
                            relative_path_t relative_path;
                            absolute_path_t sub_path, absolute_path;
                            
                            double compressed_size = zi->compressed_size;
                            double uncompressed_size = zi->uncompressed_size;
                            
#if VERSIONWIN
                            relative_path = relative_path_t(zi->filename);
                            relative_path_t sub_path_utf8 = relative_path;
#else
                            relative_path = absolute_path_t(zi->filename);
                            sub_path = relative_path;
#endif
                            if(charset == CHARSET_AUTOMATIC)
                            {
#if VERSIONMAC
                                if(sniffer)
                                {
                                    numTextEncodings = charset_num;
                                    maxErrs = relative_path.size();
                                    maxFeatures = relative_path.size();
                                    std::vector<ItemCount> _numErrsArray(charset_count);
                                    numErrsArray = &_numErrsArray[0];
                                    std::vector<ItemCount> _numFeaturesArray(charset_count);
                                    ItemCount *numFeaturesArray = &_numFeaturesArray[0];
                                    if(!TECSniffTextEncoding(sniffer,
                                                             (ConstTextPtr)relative_path.c_str(),
                                                             (ByteCount)relative_path.size(),
                                                             encodings,
                                                             numTextEncodings,
                                                             numErrsArray,
                                                             maxErrs,
                                                             numFeaturesArray,
                                                             maxFeatures))
                                    {
                                        RegionCode actualRegion;
                                        TextEncoding actualEncoding;
                                        ByteCount length;
                                        TextEncoding unicode = CreateTextEncoding(kTextEncodingUnicodeDefault,
                                                                                  kTextEncodingDefaultVariant,
                                                                                  kUnicode16BitFormat);
                                        
                                        std::vector<char> buf(len);
                                        if(!GetTextEncodingName(
                                                                encodings[0],
                                                                kTextEncodingFullName,
                                                                0,
                                                                unicode,
                                                                len,
                                                                &length,
                                                                &actualRegion,
                                                                &actualEncoding,
                                                                (TextPtr)&buf[0]))
                                        {
                                            CFStringRef name = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar*)&buf[0], (length/2));
                                            if(name)
                                            {
                                                UInt32 codepage = TextEncodingNameToWindowsCodepage(name);
                                                if(codepage > 0)
                                                {
                                                    convertPathFromCodepage(relative_path, codepage);
                                                    convertPathFromCodepage(sub_path, codepage);
                                                }
                                                CFRelease(name);
                                            }
                                        }
                                    }
                                }
#else
                                if(mlang)
                                {
                                    char *data = (char *)relative_path.c_str();
                                    size_t size = relative_path.size();
                                    int scores = numTextEncodings;
                                    std::vector<DetectEncodingInfo> encodings(scores);
                                    mlang->DetectInputCodepage(MLDETECTCP_NONE, 0, data, (INT *)&size, &encodings[0], &scores);
                                    INT confidence = 0;
                                    
                                    for(int i = 0; i < scores ; ++i)
                                    {
                                        if(encodings[i].nLangID != 0)
                                        {
                                            if(confidence < encodings[i].nConfidence){
                                                codepage = encodings[i].nCodePage;
                                            }
                                        }
                                    }
                                    if(codepage > 0)
                                    {
                                        convertPathFromCodepage(relative_path, codepage, mlang);
                                        convertPathFromCodepage(sub_path_utf8, codepage, mlang);
                                    }
                                }
#endif
                            }else if(charset > 0)
                            {
#if VERSIONMAC
                                convertPathFromCodepage(relative_path, charset);
                                convertPathFromCodepage(sub_path, charset);
#else
                                convertPathFromCodepage(relative_path, charset, mlang);
                                convertPathFromCodepage(sub_path_utf8, charset, mlang);
#endif
                            }
                            
#if VERSIONWIN
                            unescape_path(sub_path_utf8);
                            utf8_to_wcs(sub_path_utf8, sub_path);
#endif
                            
                            absolute_path = output;
                            absolute_path+= folder_separator + sub_path;
                            
                            if(isCallbackSet)
                            {
#if LESS_CALLBACK
                                time_t now = time(0);
                                time_t elapsedTime = abs(startTime - now);
                                if(elapsedTime > 0)
                                {
                                    startTime = now;
#endif
                                    if(method_id)
                                    {
                                        C_TEXT tempUstr;
                                        tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), (uint32_t)relative_path.length());
                                        PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                        PA_SetStringVariable(&cbparams[0], &methodParam1);
                                        tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                                        PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                        PA_SetStringVariable(&cbparams[1], &methodParam2);
                                        
                                        PA_SetRealVariable(&cbparams[2], num_of_file);
                                        PA_SetRealVariable(&cbparams[3], number_entry);
                                        PA_SetRealVariable(&cbparams[4], compressed_size);
                                        PA_SetRealVariable(&cbparams[5], uncompressed_size);
                                        
                                        PA_Variable result = PA_ExecuteMethodByID(method_id, cbparams, 6);
                                        
                                        if(PA_GetVariableKind(result) == eVK_Boolean)
                                            abortedByCallbackMethod = PA_GetBooleanVariable(result);
                                        
                                    }else
                                    {
                                        /*
                                         
                                         In previous versions, it was possible to invoke a shared component method with PA_ExecuteCommandByID and EXECUTE METHOD:C1007. This is no longer possible. Now, only a method in the host database can be invoked (PA_ExecuteMethodByID is allowed).
                                         
                                         */
                                        
                                        PA_SetBooleanVariable(&cbparams[1], false);
                                        
                                        C_TEXT tempUstr;
                                        tempUstr.setUTF8String((const uint8_t *)relative_path.c_str(), (uint32_t)relative_path.length());
                                        PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                        PA_SetStringVariable(&cbparams[2], &methodParam1);
                                        tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                                        PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                        PA_SetStringVariable(&cbparams[3], &methodParam2);
                                        
                                        PA_SetRealVariable(&cbparams[4], num_of_file);
                                        PA_SetRealVariable(&cbparams[5], number_entry);
                                        PA_SetRealVariable(&cbparams[6], compressed_size);
                                        PA_SetRealVariable(&cbparams[7], uncompressed_size);
                                        
                                        PA_ExecuteCommandByID(1007, cbparams, 8);
                                        
                                        abortedByCallbackMethod = PA_GetBooleanVariable(cbparams[1]);
                                    }
#if LESS_CALLBACK
                                }
#endif
                            }
                            
                            if(!abortedByCallbackMethod)
                            {
                                if(relative_path.size() > 0)
                                {
                                    if( !ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos))
                                    {
                                        create_parent_folder(absolute_path);
                                        
                                        if(relative_path.at(relative_path.size() - 1) == folder_separator)
                                        {
                                            
                                            create_folder(absolute_path);
                                        }
                                        
                                        bool is_symbolic_link = false;
#if VERSIONMAC
                                        if(with_atttributes){
                                            
                                            if(((zi->external_fa >> 16L) & 0xA000) == 0xA000)
                                            {
                                                std::vector<char> _buf(PATH_MAX);
                                                err = mz_zip_entry_read_open(h->zip_handle, h->raw, pass);
                                                if (err == MZ_OK)
                                                {
                                                    int32_t read = mz_zip_entry_read(h->zip_handle, &_buf[0], PATH_MAX);
                                                    if(read > 0)
                                                    {
                                                        std::string symlink_absolute_path = absolute_path;
                                                        NSString *_symlinkSrcPath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, symlink_absolute_path.c_str());
                                                        symlink_absolute_path = absolute_path_t([[_symlinkSrcPath stringByDeletingLastPathComponent]fileSystemRepresentation]);
                                                        [_symlinkSrcPath release];
                                                        symlink_absolute_path += folder_separator + std::string((char *)&_buf[0]);
                                                        NSString *symlinkDstPath = [[NSString alloc]initWithUTF8String:symlink_absolute_path.c_str()];
                                                        [symlinkDstPaths addObject:symlinkDstPath];
                                                        [symlinkDstPath release];
                                                        
                                                        NSString *symlinkSrcPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                                        [symlinkSrcPaths addObject:symlinkSrcPath];
                                                        [symlinkSrcPath release];
                                                        
                                                        is_symbolic_link = true;
                                                    }
                                                    
                                                    mz_zip_entry_close(h->zip_handle);
                                                }
                                                
                                            }
                                            
                                        }
#endif
                                        if(!is_symbolic_link)
                                        {
                                            std::ofstream ofs(absolute_path.c_str(), std::ios::out|std::ios::binary);
                                            
                                            if(ofs.is_open())
                                            {
                                                int32_t read;
                                                
                                                err = mz_zip_entry_read_open(h->zip_handle, h->raw, pass);
                                                
                                                if (err == MZ_OK)
                                                {
                                                    while ((read = mz_zip_entry_read(h->zip_handle, &buf[0], BUFFER_SIZE)) > 0)
                                                    {
                                                        yield_counter++;
                                                        
                                                        ofs.write((const char *)&buf[0], read);
                                                        
                                                        if((yield_counter % YIELD_FACTOR) == 0)
                                                        {
                                                            PA_YieldAbsolute();
                                                        }
                                                    }
                                                    
                                                    mz_zip_entry_close(h->zip_handle);
                                                    
                                                }
                                                ofs.close();
                                            }
                                            
                                        }
#if VERSIONMAC
                                        if(with_atttributes)
                                        {
                                            short permission = (zi->external_fa >> 16L) & 0x01FF;
                                            
                                            if(permission)
                                            {
                                                yield_counter++;
                                                
                                                NSDictionary *itemAttributes = [NSDictionary
                                                                                dictionaryWithObject:[NSNumber numberWithShort:permission]
                                                                                forKey:NSFilePosixPermissions];
                                                
                                                NSString *fullPath = [[NSString alloc]initWithUTF8String:absolute_path.c_str()];
                                                [fm setAttributes:itemAttributes ofItemAtPath:fullPath error:nil];
                                                [fullPath release];
                                            }
                                            
                                        }
#endif
                                    }
                                    
                                }
                            }
                            
                            err = mz_zip_reader_goto_next_entry(reader);
                            
                            if (err == MZ_OK)
                            {
                                num_of_file++;
                            }
                        }
                        
                        PA_Variable cbparams;
                        bool isProcessDying = PA_GetBooleanVariable(PA_ExecuteCommandByID(672/* Process aborted */, &cbparams, 0));
                        /* PA_IsProcessDying is not threadSafe */
                        
                        if(isProcessDying)
                        {
                            /* abort (runtime explorer, not debugger) */
                            abortedByCallbackMethod = true;
                            goto unzip_abort_transfer;
                        }
                    }
                    
                    while (err == MZ_OK && !abortedByCallbackMethod);
#if VERSIONMAC
                    if(!abortedByCallbackMethod)
                    {
                        NSUInteger count = [symlinkSrcPaths count];
                        
                        for(NSUInteger i = 0; i < count; ++i)
                        {
                            NSMutableArray *symlinkSrcPathsCopy = [[NSMutableArray alloc]initWithArray:symlinkSrcPaths];
                            NSMutableArray *symlinkDstPathsCopy = [[NSMutableArray alloc]initWithArray:symlinkDstPaths];
                            
                            for(NSUInteger j = 0; j < [symlinkSrcPathsCopy count]; ++j)
                            {
                                NSString *symlinkSrcPath = [symlinkSrcPathsCopy objectAtIndex:j];
                                NSString *symlinkDstPath = [symlinkDstPathsCopy objectAtIndex:j];
                                
                                BOOL isDirectory;
                                if([fm fileExistsAtPath:symlinkDstPath isDirectory:&isDirectory])
                                {
                                    if([fm createSymbolicLinkAtPath:symlinkSrcPath
                                                withDestinationPath:symlinkDstPath
                                                              error:nil])
                                    {
                                        [symlinkSrcPaths removeObjectIdenticalTo:symlinkSrcPath];
                                        [symlinkDstPaths removeObjectIdenticalTo:symlinkDstPath];
                                    }
                                    //                                else{
                                    //                                    NSLog(@"symlink points to a symlink path: %@", symlinkDstPath);
                                    //                                }
                                    
                                }
                                
                            }
                            if([symlinkSrcPaths count] == 0)
                            {
                                break;
                            }
                            //                        else{
                            //                            NSLog(@"%d more links to create", [symlinkSrcPaths count]);
                            //                        }
                        }
                        
                    }
#endif
                }
   
            }
            
        }
        
    unzip_abort_transfer:
        
        PA_ClearVariable(&cbparams[0]);
        PA_ClearVariable(&cbparams[1]);
        PA_ClearVariable(&cbparams[2]);
        PA_ClearVariable(&cbparams[3]);
        PA_ClearVariable(&cbparams[4]);
        PA_ClearVariable(&cbparams[5]);
        PA_ClearVariable(&cbparams[6]);
        PA_ClearVariable(&cbparams[7]);
        
#if VERSIONMAC
        [symlinkSrcPaths release];
        [symlinkDstPaths release];
        
        [fm release];
        
        if(sniffer)
        {
            TECDisposeSniffer(sniffer);
        }
#endif
        mz_zip_reader_close(reader);
    }
    
    mz_zip_reader_delete(&reader);
    
#if VERSIONWIN
    if(mlang)
    {
        mlang->Release();
    }
#endif
    
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }
    
    returnValue.setReturn(pResult);
}

void Zip(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT Param4;
    C_LONGINT Param5;
    C_TEXT Param6;
    C_LONGINT Param7;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);//src
    Param2.fromParamAtIndex(pParams, 2);//dst
    Param3.fromParamAtIndex(pParams, 3);//pass
    Param4.fromParamAtIndex(pParams, 4);//level
    Param5.fromParamAtIndex(pParams, 5);//options
    Param6.fromParamAtIndex(pParams, 6);//callback
    Param7.fromParamAtIndex(pParams, 7);//codepage
    
    //src
    absolute_paths_t absolute_paths;
    relative_paths_t relative_paths;
    relative_path_t input_file_name;
    
    //pass
    std::string password;
    convertToString(Param3, password);
    bool with_password = (password.length() != 0);
    const char *pass = with_password ? password.c_str() : NULL;
    
    //dst
    CUTF8String output_path;
    Param2.copyPath(&output_path);
    const char *output = (const char*)output_path.c_str();
    
    //level
    unsigned int level = Param4.getIntValue();
    if(!level){
        level = MZ_COMPRESS_LEVEL_DEFAULT;
    }else if (level > 10){
        level = 9;
    }
    
    unsigned int flags = Param5.getIntValue();
    
    bool ignore_dot = !!(flags & 1L);
    
#if VERSIONMAC
    bool with_atttributes = !!(flags & 2L);
#else
    bool with_atttributes = false;
#endif
    
    bool without_enclosing_folder = !!(flags & 4L);
    bool with_encyption = !!(flags & 8L);
    
    bool with_bz2 = !!(flags & 16L);
    bool with_lzma = !!(flags & 32L);
    
#if VERSIONWIN
    IMultiLanguage2 *mlang = NULL;
    CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void **)&mlang);
#endif
    
    //callback
#if USE_PA_EXECUTE_METHOD_BY_ID
    PA_long32 method_id = PA_GetMethodID((PA_Unichar *)Param6.getUTF16StringPtr());
#else
    PA_long32 method_id = 0;
#endif
    
//    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
#if LESS_CALLBACK
    time_t startTime = time(0);
    unsigned int yield_counter = 0;
#endif
    
    bool isCallbackSet = Param6.getUTF16Length();
    
    bool abortedByCallbackMethod = false;
    //    bool use_callback = Param6.getUTF16Length();
    
    PA_Variable    cbparams[6];
    
    if(method_id)
    {
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Unistring);
        cbparams[2] = PA_CreateVariable(eVK_Real);
        cbparams[3] = PA_CreateVariable(eVK_Real);
        cbparams[4] = PA_CreateVariable(eVK_Undefined);
        cbparams[5] = PA_CreateVariable(eVK_Undefined);
    }else{
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Boolean);
        cbparams[2] = PA_CreateVariable(eVK_Unistring);
        cbparams[3] = PA_CreateVariable(eVK_Unistring);
        cbparams[4] = PA_CreateVariable(eVK_Real);
        cbparams[5] = PA_CreateVariable(eVK_Real);
        PA_SetUnistring((&(cbparams[0].uValue.fString)),
                        (PA_Unichar *)Param6.getUTF16StringPtr());
    }
    
    int charset = Param7.getIntValue();
    
    get_subpaths(Param1, &relative_paths, &absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);
    
    if(relative_paths.size()){
        
        void *writer = NULL;
        int16_t compress_method = MZ_COMPRESS_METHOD_DEFLATE;
        
        if(with_bz2)
        {
            compress_method = MZ_COMPRESS_METHOD_BZIP2;
        }
        
        if(with_lzma)
        {
            compress_method = MZ_COMPRESS_METHOD_LZMA;
        }
        
        unsigned int yield_counter = 0;
        
        mz_zip_writer_create(&writer);
        
        mz_zip_writer *h = (mz_zip_writer *)writer;
        std::vector<uint8_t> buf(BUFFER_SIZE);
        
        double number_entry = relative_paths.size();
        
        if(with_password)
        {
            mz_zip_writer_set_password(writer, pass);
        }
        
        mz_zip_writer_set_compress_method(writer, compress_method);
        mz_zip_writer_set_compress_level(writer, level);
        
        mz_zip_writer_set_aes(writer, with_encyption);
        
        int32_t err = mz_zip_writer_open_file(writer, output, 0, 0);
        
        if (err == MZ_OK)
        {
            
            returnValue.setIntValue(1);
            
#if VERSIONMAC
            NSFileManager *fm = [[NSFileManager alloc]init];
#endif
            
            for (unsigned int i = 0; i < relative_paths.size(); ++i)
            {
                relative_path_t relative_path = relative_paths.at(i);
                absolute_path_t absolute_path = absolute_paths.at(i);
                relative_path_t relative_path_utf8 = relative_path;
                relative_path_t absolute_path_utf8;
                relative_path_t symbolic_path_utf8;
                
                bool isSymbolicLink = false;
#if VERSIONMAC
                absolute_path_utf8 = absolute_path;
#else
                wcs_to_utf8(absolute_path, absolute_path_utf8);
#endif
                const char *path = absolute_path_utf8.c_str();
                
                mz_zip_file zi;
                memset(&zi, 0, sizeof(zi));
                
                zi.version_madeby = MZ_VERSION_MADEBY;
                
#if VERSIONMAC
                if(with_atttributes)
                {
                    NSString *symbolicPath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
                    NSString *destinationPath = [fm destinationOfSymbolicLinkAtPath:symbolicPath error:nil];
                    if(destinationPath){
                        symbolic_path_utf8 = relative_path_t([destinationPath UTF8String]);
                        [symbolicPath release];
                        isSymbolicLink = TRUE;
                    }
                }
#endif
                if(charset > 0)
                {
#if VERSIONMAC
                    convertPathToCodepage(relative_path, charset);
#else
                    convertPathToCodepage(relative_path, charset, mlang);
#endif
                    zi.flag &= ~MZ_ZIP_FLAG_UTF8;
                }else
                {
                    zi.flag |=  MZ_ZIP_FLAG_UTF8;
                }
                zi.filename = relative_path.c_str();
                zi.uncompressed_size = mz_os_get_file_size(path);
                
                zi.compression_method = compress_method;
                if(with_encyption)
                {
                    zi.aes_version = MZ_AES_VERSION;
                }
                mz_os_get_file_date(path,
                                    &zi.modified_date,
                                    &zi.accessed_date,
                                    &zi.creation_date);
                
                mz_os_get_file_attribs(path, &zi.external_fa);
#if VERSIONMAC
                if(with_atttributes)
                {
                    NSDictionary *attributes = [fm attributesOfItemAtPath:
                                                [NSString stringWithUTF8String:(const char *)absolute_path.c_str()]error:nil];
                    if(attributes)
                    {
                        
                        if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeCharacterSpecial])
                        {
                            zi.external_fa = 0x20000000;
                        }else
                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory])
                            {
                                zi.external_fa = 0x40000000;
                            }else
                                if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeBlockSpecial])
                                {
                                    zi.external_fa = 0x60000000;
                                }else
                                    if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular])
                                    {
                                        zi.external_fa = 0x80000000;
                                    }else
                                        if(([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink]))
                                        {
                                            zi.external_fa = 0xA0000000;
                                        }else
                                            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSocket])
                                            {
                                                zi.external_fa = 0xC0000000;
                                            }
                        zi.external_fa |= ([[attributes valueForKey:NSFilePosixPermissions]shortValue] << 16L);
                        
                    }//attributes
                    
                }//with_atttributes
#endif
                bool is_dir = (mz_zip_attrib_is_dir(zi.external_fa, zi.version_madeby) == MZ_OK);
                
                if(with_password)
                {
                    if(is_dir)
                    {
                        mz_zip_writer_set_password(writer, NULL);/* mac archiver does not process password for folder */
                    }else
                    {
                        mz_zip_writer_set_password(writer, pass);
                    }
                }
                
                if(mz_zip_writer_entry_open(writer, &zi) == MZ_OK)
                {
                    if (!is_dir)
                    {
                        if(with_password)
                        {
                            mz_zip_writer_set_password(writer, pass);
                        }
                        std::ifstream ifs(absolute_path.c_str(), std::ios::in|std::ios::binary);
                        if(ifs.is_open())
                        {
                            if(isSymbolicLink)
                            {
                                yield_counter++;
                                int32_t read = (int32_t)symbolic_path_utf8.length();
                                int32_t written = mz_zip_entry_write(h->zip_handle, symbolic_path_utf8.c_str(), read);
                                if (written != read)/* MZ_STREAM_ERROR */
                                {
                                    returnValue.setIntValue(0);
                                    break;
                                }
                            }else
                            {
                                while(ifs.good())
                                {
                                    yield_counter++;
                                    if((yield_counter % YIELD_FACTOR) == 0)
                                    {
                                        PA_YieldAbsolute();
                                    }
                                    ifs.read((char *)&buf[0], BUFFER_SIZE);
                                    int32_t read = (int32_t)ifs.gcount();
                                    int32_t written = mz_zip_entry_write(h->zip_handle, &buf[0], read);
                                    if (written != read)/* MZ_STREAM_ERROR */
                                    {
                                        returnValue.setIntValue(0);
                                        break;
                                    }
                                }
                            }
                            
                            ifs.close();
                        }
                    }
                    err = mz_zip_writer_entry_close(writer);
                    
                    if(isCallbackSet)
                    {
#if LESS_CALLBACK
                        time_t now = time(0);
                        time_t elapsedTime = abs(startTime - now);
                        if(elapsedTime > 0)
                        {
                            startTime = now;
#endif
                            if(method_id)
                            {
                                C_TEXT tempUstr;
                                tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), (uint32_t)relative_path_utf8.length());
                                PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                PA_SetStringVariable(&cbparams[0], &methodParam1);
                                tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                                PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                PA_SetStringVariable(&cbparams[1], &methodParam2);
                                
                                PA_SetRealVariable(&cbparams[2], i+1);
                                PA_SetRealVariable(&cbparams[3], number_entry);
                                
                                PA_Variable result = PA_ExecuteMethodByID(method_id, cbparams, 4);
                                
                                if(PA_GetVariableKind(result) == eVK_Boolean)
                                    abortedByCallbackMethod = PA_GetBooleanVariable(result);
                                
                            }else
                            {
                                /*
                                 
                                In previous versions, it was possible to invoke a shared component method with PA_ExecuteCommandByID and EXECUTE METHOD:C1007. This is no longer possible. Now, only a method in the host database can be invoked (PA_ExecuteMethodByID is allowed).
                                 
                                 */
                                
                                PA_SetBooleanVariable(&cbparams[1], false);
                                
                                C_TEXT tempUstr;
                                tempUstr.setUTF8String((const uint8_t *)relative_path_utf8.c_str(), (uint32_t)relative_path_utf8.length());
                                PA_Unistring methodParam1 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                PA_SetStringVariable(&cbparams[2], &methodParam1);
                                tempUstr.setUTF8String((const uint8_t *)absolute_path.c_str(), (uint32_t)absolute_path.length());
                                PA_Unistring methodParam2 = PA_CreateUnistring((PA_Unichar *)tempUstr.getUTF16StringPtr());
                                PA_SetStringVariable(&cbparams[3], &methodParam2);
                                
                                PA_SetRealVariable(&cbparams[4], i+1);
                                PA_SetRealVariable(&cbparams[5], number_entry);
                                PA_ExecuteCommandByID(1007, cbparams, 6);
                                
                                abortedByCallbackMethod = PA_GetBooleanVariable(cbparams[1]);
                                
                            }
                            
                            if(abortedByCallbackMethod)
                            {
                                goto zip_abort_transfer;
                            }
#if LESS_CALLBACK
                        }
#endif
                    }
                    
                    PA_Variable params;
                    bool isProcessDying = PA_GetBooleanVariable(PA_ExecuteCommandByID(672/* Process aborted */, &params, 0));
                    /* PA_IsProcessDying is not threadSafe */
                    
                    if(isProcessDying)
                    {
                        /* abort (runtime explorer, not debugger) */
                        abortedByCallbackMethod = true;
                        goto zip_abort_transfer;
                    }
                    
                }/* mz_zip_writer_entry_open */
                
            }/* for (unsigned int i = 0; i < relative_paths.size(); ++i) */
            
        zip_abort_transfer:
            
            PA_ClearVariable(&cbparams[0]);
            PA_ClearVariable(&cbparams[1]);
            PA_ClearVariable(&cbparams[2]);
            PA_ClearVariable(&cbparams[3]);
            PA_ClearVariable(&cbparams[4]);
            PA_ClearVariable(&cbparams[5]);
            
#if VERSIONMAC
            [fm release];
#endif
            mz_zip_writer_close(writer);
            
        }/*  if (err == MZ_OK) */
        mz_zip_writer_delete(&writer);
    }
    
#if VERSIONWIN
    if(mlang)
    {
        mlang->Release();
    }
#endif
    
    if(abortedByCallbackMethod){
        returnValue.setIntValue(0);
    }
    
    returnValue.setReturn(pResult);
}


#pragma mark -

#if VERSIONMAC
void convertPathToCodepage(std::string &path, UInt32 codepage) {
    
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
    if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
    {
        NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
                                                            (const UInt8 *)path.c_str(),
                                                            path.length(),
                                                            kCFStringEncodingUTF8,
                                                            true);
        if(str)
        {
            CFIndex size = CFStringGetMaximumSizeForEncoding([str length], encoding) + sizeof(PA_Unichar);    //2 bytes for null termination
            std::vector<uint8_t> buf(size);
            CFIndex len = 0;
            CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), encoding, '?', false, (UInt8 *)&buf[0], size, &len);
            path = relative_path_t((char *)&buf[0], len);
            [str release];
        }
    }
}
#else
void convertPathToCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang) {
    
    if(mlang)
    {
        C_TEXT tempUstr;
        UINT len, mlen, ulen;
        DWORD mode = 0;
        tempUstr.setUTF8String((const uint8_t *)path.c_str(), path.length());
        ulen = -1;
        LPWSTR ustr = (LPWSTR)tempUstr.getUTF16StringPtr();
        mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, NULL, &mlen);
        len = mlen+2;
        std::vector<uint8_t> buf(len);
        if(S_OK == mlang->ConvertStringFromUnicode(&mode, codepage, ustr, &ulen, (CHAR *)&buf[0], &mlen))
        {
            path = std::string((char *)&buf[0]);
        }
    }
}
#endif

#if VERSIONMAC
void convertPathFromCodepage(std::string &path, UInt32 codepage) {
    
    CFStringEncoding encoding = _CFStringConvertWindowsCodepageToEncoding(codepage);
    if((encoding != kCFStringEncodingInvalidId) && CFStringIsEncodingAvailable(encoding))
    {
        NSString *str = (NSString *)CFStringCreateWithBytes(kCFAllocatorDefault,
                                                            (const UInt8 *)path.c_str(),
                                                            path.length(),
                                                            encoding,
                                                            true);
        if(str)
        {
            CFIndex size = CFStringGetMaximumSizeForEncoding([str length], kCFStringEncodingUTF8) + sizeof(PA_Unichar);    //2 bytes for null termination
            std::vector<uint8_t> buf(size);
            CFIndex len = 0;
            CFStringGetBytes((CFStringRef)str, CFRangeMake(0, [str length]), kCFStringEncodingUTF8, '?', false, (UInt8 *)&buf[0], size, &len);
            path = std::string((char *)&buf[0], len);
            [str release];
        }
    }
}
#else
void convertPathFromCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang) {
    
    if(mlang)
    {
        LPSTR mstr = (LPSTR)path.c_str();
        UINT mlen = -1;
        UINT ulen, len;
        DWORD mode = 0;
        mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, NULL, &ulen);
        len = ((ulen * 2) + 2);
        std::vector<uint8_t> buf(len);
        if(S_OK == mlang->ConvertStringToUnicode(&mode, codepage, mstr, &mlen, (WCHAR *)&buf[0], &ulen))
        {
            C_TEXT tempUstr;
            tempUstr.setUTF16String((const PA_Unichar *)&buf[0], ulen);
            CUTF8String tempStr;
            tempUstr.copyUTF8String(&tempStr);
            path = std::string((char *)tempStr.c_str());
        }
    }
}
#endif

#ifdef WIN32

using namespace std;

int wcs_to_utf8(wstring& wstr, string& str) {
    
    int error = 0;
    
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    if(len){
        vector<char> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)wstr.c_str(), wstr.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            str = string((const char *)&buf[0]);
        }
    }else{
        str = string((const char *)"");
        error = -1;
    }
    
    return error;
    
}

int utf8_to_wcs(string& str, std::wstring& wstr) {
    
    int error = 0;
    
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);
    if(len){
        vector<char> buf((len + 1) * sizeof(wchar_t));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)){
            wstr = wstring((const wchar_t *)&buf[0]);
        }
    }else{
        wstr = wstring((const wchar_t *)L"");
        error = -1;
    }
    
    return error;
    
}

void unescape_path(string &path) {
    
    wstring wpath;
    utf8_to_wcs(path, wpath);
    unescape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void escape_path(string &path) {
    
    wstring wpath;
    utf8_to_wcs(path, wpath);
    escape_path(wpath);
    wcs_to_utf8(wpath, path);
}

void unescape_path(wstring &path) {
    
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '/')
            path.at(i) = L'\\';
}

void escape_path(wstring &path) {
    
    for (unsigned int i = 0; i < path.size(); ++i)
        if (path.at(i) == '\\')
            path.at(i) = L'/';
}

void get_subpaths(wstring& path,
                  absolute_paths_t *absolute_paths,
                  relative_paths_t *relative_paths,
                  relative_path_t& folder_name,
                  bool ignore_dot,
                  bool without_enclosing_folder,
                  size_t absolutePathOffset = 0) {
    
    WIN32_FIND_DATA find;
    
    HANDLE h = FindFirstFile(path.c_str(), &find);
    
    absolute_path_t absolute_path;
    relative_path_t relative_path;
    
    if(h != INVALID_HANDLE_VALUE){
        
        unsigned int yield_counter = 0;
        
        do {
            
            yield_counter++;
            if ((yield_counter % YIELD_FACTOR) == 0)
            {
                PA_YieldAbsolute();
            }
            
            wstring sub_path = find.cFileName;
            
            /* ignore these meta */
            if((!wcscmp(sub_path.c_str(), L"..")) || (!wcscmp(sub_path.c_str(), L".")))
                continue;
            
            if((find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
            {
                /* is a folder */
                if(!absolutePathOffset)
                {
                    /* is top level */
                    /* use this length to convert absolute path to relative */
                    absolutePathOffset = path.size() - 1;
                    
                    wcs_to_utf8(sub_path + L"/", folder_name);
                    
                    /* if flag specified, ignore (special option for top level) */
                    if(!without_enclosing_folder)
                    {
                        absolute_paths->push_back(path);
                        relative_paths->push_back(folder_name);
                    }
                    
                    /* recursive call with wildcard */
                    get_subpaths(path + L"\\*",
                                 absolute_paths,
                                 relative_paths,
                                 folder_name,
                                 ignore_dot,
                                 without_enclosing_folder,
                                 absolutePathOffset);
                    
                }else{
                    /* not top level */
                    /* trim the wildcard */
                    absolute_path = path.substr(0, path.size() - 1) + sub_path;
                    
                    wstring base_path = absolute_path.substr(absolutePathOffset + 2);
                    /* base_path += sub_path;*/
                    /* because this is a folder path */
                    base_path += L"\\";
                    escape_path(base_path);
                    wcs_to_utf8(base_path, relative_path);
                    relative_path = folder_name + relative_path;
                    
                    bool is_hidden = (GetFileAttributes(absolute_path.c_str()) & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN;
                    is_hidden |= (relative_path.at(0) == '.');/* invisible folder for mac */
                    is_hidden |= (relative_path.find("/.") != string::npos);/* invisible folder in path */
                    
                    if(!(ignore_dot & is_hidden))
                    {
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder)
                        {
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                        
                        get_subpaths(absolute_path /* + sub_path */ + L"\\*",
                                     absolute_paths,
                                     relative_paths,
                                     folder_name,
                                     ignore_dot,
                                     without_enclosing_folder,
                                     absolutePathOffset);
                        
                    }
                    
                }
                
            }else{
                /* is file */
                if(!absolutePathOffset)
                {
                    /* top level */
                    absolute_path = path;// + sub_path;
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
                    
                    absolute_paths->push_back(absolute_path);
                    relative_paths->push_back(relative_path);
                    
                }else{
                    /* not top level */
                    wstring base_path = path.substr(0, path.size() - 1);
                    absolute_path = base_path + sub_path;
                    
                    sub_path = base_path.substr(absolutePathOffset + 2) + sub_path;
                    
                    escape_path(sub_path);
                    wcs_to_utf8(sub_path, relative_path);
                    relative_path = folder_name + relative_path;
                    
                    bool is_hidden = (GetFileAttributes(absolute_path.c_str()) & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN;
                    is_hidden |= (relative_path.at(0) == '.');/* invisible folder for mac */
                    is_hidden |= (relative_path.find("/.") != string::npos);/* invisible folder in path */
                    
                    if(!(ignore_dot & is_hidden))
                    {
                        absolute_paths->push_back(absolute_path);
                        
                        if(!without_enclosing_folder)
                        {
                            relative_paths->push_back(relative_path);
                        }else{
                            relative_paths->push_back(relative_path.substr(folder_name.length()));
                        }
                    }
                    
                }
                
            }
            
        } while (FindNextFile(h, &find));
        /*
         if(!absolute_paths->size() && absolutePathOffset){
         wstring base_path = path.substr(0, path.size() - 1);
         relative_paths->push_back(folder_name);
         absolute_paths->push_back(base_path);
         }
         */
        FindClose(h);
        
    }
    
}
#endif

void convertToString(C_TEXT &fromString, std::string &toString) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), (LPSTR)&buf[0], len, NULL, NULL)){
            toString = std::string((const char *)&buf[0]);
        }
    }else{
        toString = std::string((const char *)"\0");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)fromString.getUTF16StringPtr(), fromString.getUTF16Length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        
        toString = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void get_subpaths(absolute_path_t& spath,
                  relative_paths_t *relative_paths,
                  absolute_paths_t *absolute_paths,
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder) {
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, spath.c_str());
    
    //semantically the same string but the result from subpathsOfDirectoryAtPath is wrong if we use this:
    //NSString *path = Param.copyPath();
    //maybe because of trailing nulls?
    
    NSFileManager *fm = [[NSFileManager alloc]init];
    
    BOOL isDirectory = YES;
    
    if(with_atttributes){
        
        NSDictionary *attributes = [fm attributesOfItemAtPath:path error:nil];
        
        if(attributes){
            if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeSymbolicLink]
               || [[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeRegular]){
                
                //over-ride ignore_dot, this is top level
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
                
            }else
                if([[attributes valueForKey:NSFileType]isEqualToString:NSFileTypeDirectory]){
                    
                    NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                    NSString *folderPath = [path stringByDeletingLastPathComponent];
                    if(![[folderPath substringFromIndex:[folderPath length]]isEqualToString:@"/"]){
                        folderPath = [folderPath stringByAppendingString:@"/"];
                    }
                    
                    NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES];
                    NSString *basePath = [baseUrl path];
                    if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                        basePath = [basePath stringByAppendingString:@"/"];
                    }
                    
                    if(!without_enclosing_folder){
                        relative_paths->push_back([folderName UTF8String]);
                        absolute_paths->push_back([basePath UTF8String]);
                    }
                    
                    NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:baseUrl
                                              includingPropertiesForKeys:[NSArray arrayWithObjects:NSURLIsDirectoryKey, NSURLIsHiddenKey, nil]
                                                                 options:0
                                                            errorHandler:nil];
                    unsigned int yield_counter = 0;
                    while(NSURL *u = [dirEnum nextObject]){
                        
                        yield_counter++;
                        if((yield_counter % YIELD_FACTOR) == 0)
                        {
                            PA_YieldAbsolute();
                        }
                        
                        NSNumber *isDirectory;
                        [u getResourceValue:&isDirectory forKey:NSURLIsDirectoryKey error:nil];
                        
                        NSNumber *isHidden;
                        [u getResourceValue:&isHidden forKey:NSURLIsHiddenKey error:nil];
                        
                        NSString *fullPath = [u path];
                        
                        if([isDirectory boolValue])
                            fullPath = [fullPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [fullPath UTF8String];
                        relative_path_t relative_path = [[fullPath substringFromIndex:[folderPath length]]UTF8String];
                        
                        if(!ignore_dot || (((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos) && ![isHidden boolValue])){
                            
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);
                            }else{
                                relative_paths->push_back([[fullPath substringFromIndex:[basePath length]]UTF8String]);
                            }
                        }
                    }
                }
        }//attributes
        
    }else{
        
        if([fm fileExistsAtPath:path isDirectory:&isDirectory]){
            
            if(isDirectory){
                
                NSString *folderName = [[path lastPathComponent]stringByAppendingString:@"/"];
                
                NSURL *baseUrl = [NSURL fileURLWithPath:path isDirectory:YES];
                NSString *basePath = [baseUrl path];
                if(![[basePath substringFromIndex:[basePath length]]isEqualToString:@"/"]){
                    basePath = [basePath stringByAppendingString:@"/"];
                }
                
                NSArray *paths = (NSMutableArray *)[fm subpathsOfDirectoryAtPath:path error:NULL];
                
                if(!without_enclosing_folder){
                    relative_paths->push_back([folderName UTF8String]);
                    absolute_paths->push_back([basePath UTF8String]);
                }
                
                //a folder with contents
                
                for(NSUInteger i = 0; i < [paths count]; i++){
                    
                    
                    if((i % YIELD_FACTOR) == 0)
                    {
                        PA_YieldAbsolute();
                    }
                    
                    NSString *itemPath = [paths objectAtIndex:i];
                    NSString *itemFullPath = [path stringByAppendingPathComponent:itemPath];
                    
                    if([fm fileExistsAtPath:itemFullPath isDirectory:&isDirectory]){
                        
                        if(isDirectory)
                            itemPath = [itemPath stringByAppendingString:@"/"];
                        
                        absolute_path_t absolute_path = [itemFullPath UTF8String];
                        relative_path_t relative_path = [[folderName stringByAppendingString:itemPath]UTF8String];
                        
                        if(!ignore_dot || ((relative_path.at(0) != '.') && relative_path.find("/.") == std::string::npos)){
                            
                            
                            absolute_paths->push_back(absolute_path);
                            
                            if(!without_enclosing_folder){
                                relative_paths->push_back(relative_path);
                            }else{
                                relative_paths->push_back([itemPath UTF8String]);
                            }
                        }
                    }
                }
                
            }else{
                //a file (over-ride ignore_dot, this is top level)
                relative_paths->push_back(std::string([[path lastPathComponent]UTF8String]));
                absolute_paths->push_back(spath);
            }
            
        }
        
    }
    
    [path release];
    [fm release];
    
#else
    relative_path_t folder_name;
    
    get_subpaths(spath, absolute_paths, relative_paths, folder_name, ignore_dot, without_enclosing_folder);
#endif
}

void get_subpaths(C_TEXT& Param,
                  relative_paths_t *relative_paths,
                  absolute_paths_t *absolute_paths,
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder) {
    
    relative_paths->clear();
    absolute_paths->clear();
    
    using namespace Json;
    using namespace std;
    
    string paths_json;
    convertToString(Param, paths_json);
    
    CharReaderBuilder builder;
    CharReader *reader = builder.newCharReader();
    Value root;
    string errors;
    
    bool parsingSuccessful;
    
    parsingSuccessful = reader->parse(paths_json.c_str(),
                                      paths_json.c_str() + paths_json.size(),
                                      &root,
                                      &errors);
    delete reader;
    
    vector<string>sources(0);
    
    if (parsingSuccessful)
    {
        if(root.type() == arrayValue)
        {
            for(Value::const_iterator it = root.begin() ; it != root.end() ; ++it)
            {
                if(it->isString())
                {
                    sources.push_back(it->asCString());
                }
            }
        }
    }else
    {
        sources.push_back(paths_json.c_str());
    }
    
    for(size_t i = 0; i < sources.size(); ++i)
    {
        string source = sources.at(i);
        absolute_path_t spath;
        copy_path(source, spath);
        
        get_subpaths(spath, relative_paths, absolute_paths, ignore_dot, with_atttributes, without_enclosing_folder);
    }
    
}

#pragma mark -

bool create_folder(absolute_path_t& absolute_path) {
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path.c_str());
#endif
    
    return success;
}

void create_parent_folder(absolute_path_t& absolute_path) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path.c_str());
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder(folderPath);
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path.c_str(), fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder(folderPath);
#endif
}

void copy_path(std::string& t, absolute_path_t& p) {
    
    C_TEXT u;
    u.setUTF8String((const uint8_t *)t.c_str(), (uint32_t)t.length());
    copy_path(u, p);
}

void copy_path(C_TEXT& t, absolute_path_t& p) {
    
#if VERSIONMAC
    NSString *str = t.copyUTF16String();
    NSURL *u = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
    
    if(u){
        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)u, kCFURLPOSIXPathStyle);
        CFIndex size = CFStringGetMaximumSizeOfFileSystemRepresentation((CFStringRef)path);
        std::vector<uint8_t> buf(size);
        [path getFileSystemRepresentation:(char *)&buf[0] maxLength:size];
        p = std::string((char *)&buf[0]);
        [path release];
        [u release];
    }
    
    [str release];
    
#else
    p = std::wstring((wchar_t *)t.getUTF16StringPtr());
    
    if(p.at(p.size() - 1) == L'\\')
        p = p.substr(0, p.size() - 1);
#endif
}

/* --------------------------------------------------------------------------------
 #
 #	4DPlugin-Zip.h
 #	source generated by 4D Plugin Wizard
 #	Project : Zip
 #	author : miyako
 #	2019/08/30
 #  
 # --------------------------------------------------------------------------------*/

#ifndef PLUGIN_ZIP_H
#define PLUGIN_ZIP_H

#include "4DPluginAPI.h"

#pragma mark -

void Unzip(PA_PluginParameters params);
void Zip(PA_PluginParameters params);

#define HAVE_BZIP2
#define HAVE_LZMA
#define HAVE_AES
#define HAVE_ZLIB
#define HAVE_PKCRYPT

#include "mz.h"
#include "mz_os.h"
#include "mz_strm.h"
#include "mz_strm_buf.h"
#include "mz_strm_split.h"
#include "mz_zip.h"
#include "mz_zip_rw.h"
#include "mz_strm_mem.h"

typedef struct mz_zip_writer_s {
    void        *zip_handle;
    void        *file_stream;
    void        *buffered_stream;
    void        *split_stream;
    void        *mem_stream;
    mz_zip_file file_info;
    void        *overwrite_userdata;
    mz_zip_writer_overwrite_cb
    overwrite_cb;
    void        *password_userdata;
    mz_zip_writer_password_cb
    password_cb;
    void        *progress_userdata;
    mz_zip_writer_progress_cb
    progress_cb;
    void        *entry_userdata;
    mz_zip_writer_entry_cb
    entry_cb;
    const char  *password;
    int16_t     compress_method;
    int16_t     compress_level;
    uint8_t     aes;
    uint8_t     raw;
    uint8_t     buffer[UINT16_MAX];
} mz_zip_writer;

typedef struct mz_zip_reader_s {
    void        *zip_handle;
    void        *file_stream;
    void        *buffered_stream;
    void        *split_stream;
    void        *mem_stream;
    mz_zip_file *file_info;
    const char  *pattern;
    uint8_t     pattern_ignore_case;
    const char  *password;
    void        *overwrite_userdata;
    mz_zip_reader_overwrite_cb
    overwrite_cb;
    void        *password_userdata;
    mz_zip_reader_password_cb
    password_cb;
    void        *progress_userdata;
    mz_zip_reader_progress_cb
    progress_cb;
    void        *entry_userdata;
    mz_zip_reader_entry_cb
    entry_cb;
    uint8_t     raw;
    uint8_t     buffer[UINT16_MAX];
    uint8_t     legacy_encoding;
} mz_zip_reader;

#include "json/json.h"

#if VERSIONMAC
#include "codepage/cpmap.h"
#define MAX_LENGTH_FOR_ENCODING_NAME (255)
#endif

#if VERSIONWIN
#include <mlang.h>
#endif

#if VERSIONMAC
typedef std::string absolute_path_t;
#define folder_separator '/'
#else
typedef std::wstring absolute_path_t;
#define folder_separator L'\\'
#endif

typedef std::vector<absolute_path_t> absolute_paths_t;

typedef std::string relative_path_t;

typedef std::vector<relative_path_t> relative_paths_t;

typedef PA_long32 method_id_t;

#define BUFFER_SIZE 8192

#include <fstream>

#include "C_TEXT.h"
#include "C_LONGINT.h"

#if VERSIONMAC
void convertPathToCodepage(std::string &path, UInt32 codepage);
void convertPathFromCodepage(std::string &path, UInt32 codepage);
#else
void convertPathToCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang);
void convertPathFromCodepage(std::string &path, DWORD codepage, IMultiLanguage2 *mlang);
#endif

void convertToString(C_TEXT &fromString, std::string &toString);

bool create_folder(absolute_path_t& absolute_path);
void create_parent_folder(absolute_path_t& absolute_path);

void copy_path(C_TEXT& t, absolute_path_t& p);
void copy_path(std::string& t, absolute_path_t& p);

void get_subpaths(C_TEXT& Param,
                  relative_paths_t *relative_paths,
                  absolute_paths_t *absolute_paths,
                  bool ignore_dot,
                  bool with_atttributes,
                  bool without_enclosing_folder);

#define CHARSET_AUTOMATIC (-1)

#ifdef WIN32
#include <time.h>
#include <Shlobj.h>
using namespace std;
#define PATH_MAX _MAX_PATH
int wcs_to_utf8(wstring& wstr, string& str);
int utf8_to_wcs(string& str, wstring& wstr);

void unescape_path(string &path);
void unescape_path(wstring &path);

void escape_path(string &path);
void escape_path(wstring &path);

void get_last_path_component(wstring &path, string &path_component);

#endif

#define YIELD_NO_CALLBACK 1
#define LESS_CALLBACK 1
#define USE_PA_EXECUTE_METHOD_BY_ID 1
#define YIELD_FACTOR 0x0100

#endif /* PLUGIN_ZIP_H */
